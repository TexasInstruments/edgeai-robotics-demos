#  Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com/
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#
#    Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
#    Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the
#    distribution.
#
#    Neither the name of Texas Instruments Incorporated nor the names of
#    its contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import threading
import queue

from common.robot_motion_command import *

class RobotIf:
    """
    An interface class for the robot motor control.

    ...

    Attributes:
        MAX_IN_QUEUE_SIZE: int
            Maximum size of the input queue. The sender will block if the queue is full.

        IN_QUEUE_TIMEOUT: int
            The timeout value of the queue. If the queue times out then the object will
            send a stop command to the robot.

        ID_MASTER_TASK: int
            Task Id asigned to this controlling class.

    """
    MAX_IN_QUEUE_SIZE = 10
    IN_QUEUE_TIMEOUT  = 1 # in seconds
    ID_MASTER_TASK    = 12

    def __init__(self, config, queue_time_out=None):
        """
        Args:
            config: str, optional
                Name of the YAML configuration file definining the robot operational parameters.
            queue_time_out (int): Time-out for command queue reads

        """
        if config is None:
            raise ValueError('NULL configuration passed.')

        self._config           = config
        self._stop_thread      = False
        self._queue_time_out   = queue_time_out
        self.thread            = None
        self.inputQ            = None
        self._emergency_stop   = False
        self._prevCmd          = [0,0]
        self._registered_tasks = [RobotIf.ID_MASTER_TASK]
        self.stop_cmd          = MotionCommand(tskId=RobotIf.ID_MASTER_TASK)
        self.start()

    def sendCommand(self, motionCmd):
        """
        Enqueues the motion command to the input queue.

        Args:
            motionCmd: MotionCommand
                Command to be sent to the motor control. This command will be acted upon
                under the following conditions:
                - The emergency stop condition is False
                - The taskId specified in the message has been enabled through a call to
                  register_control_task() method
                - The processing thread is not in the process of stopping

        Raises:
            Propagates the exception generated by the queue module.

        """
        try:
            if motionCmd.id in self._registered_tasks:
                self.inputQ.put(motionCmd)
            else:
                # Sender has not been registered to send commands
                pass #print("{} not in registered tasks. Ignoring.".format(motionCmd.id))
        except Exception as e:
            raise

    def _control_thread(self):
        if self._robot is None:
            raise Exception('No valid robot instance exists')

        # Create an input queue
        self.inputQ = queue.Queue(maxsize=RobotIf.MAX_IN_QUEUE_SIZE)
        self._robot.setMotion(self.stop_cmd.cmd)

        # Process input commands
        while self._stop_thread == False:
            try:
                cmd = self.inputQ.get(block=True, timeout=self._queue_time_out)
                self.inputQ.task_done()
            except queue.Empty:
                # Timeout condition
                cmd = self.stop_cmd

            if self._stop_thread == True:
                self._robot.setMotion(self.stop_cmd.cmd)
                break

            # Discard the command if emergency stop flag has been set
            if self._emergency_stop == True:
                cmd = self.stop_cmd

            if ((self._prevCmd[0] != cmd.cmd[0]) or
                (self._prevCmd[1] != cmd.cmd[1])):
                # Send command to the robot
                self._robot.setMotion(cmd.cmd)
                self._prevCmd = cmd.cmd

        # Delete input queue
        del self.inputQ
        self.inputQ = None

    def set_emergency_flag(self, boolFlag):
        """
        Sets or resets the emergency stop condition. If the flag is set to True
            then all subsequent motion commands will be dropped.

        Args:
            boolFlag: bool
                A flag to set/reset emergency stop condition.

        """
        self._emergency_stop = boolFlag
        if boolFlag and self._robot:
            self.sendCommand(self.stop_cmd)

    def register_control_task(self, taskId):
        """
        Registers the entity with the taskId as a valid source for the motion commands.

        Args:
            taskId: int
                Id of the controlling task. The following are the only allowed values:
                - ID_USER_TASK
                - ID_CONTROLLER_TASK

        """
        if (taskId != ID_USER_TASK and
            taskId != ID_CONTROLLER_TASK):
            print("ERROR: Invalid taskId specified. Valid values are ID_USER_TASK, ID_CONTROLLER_TASK")
            return

        if taskId not in self._registered_tasks:
            self._registered_tasks.append(taskId)

    def unregister_control_task(self, taskId):
        """
        Un-registers a previous source for the motion commands. One unregistered, any commands from
        the source will be dropped.

        Args:
            taskId: int
                Id of the controlling task. The following are the only allowed values:
                - ID_USER_TASK
                - ID_CONTROLLER_TASK

        """
        if taskId in self._registered_tasks:
            self.sendCommand(self.stop_cmd)
            self._registered_tasks.remove(taskId)

    def wait_for_exit(self):
        """
        Method to provide a mechanism for the caller to wait for the processing
        thread to exit.
        """
        self.thread.join()
        self.thread = None
        if self._robot:
            self._robot.stop()

    def start(self):
        """
        Starts the processing thread. The caller should call wait_for_exit() if
        the calling application has no other means blocking until this object is
        destroyed.
        """
        if self.thread == None:
            self._robot = None # Plugin your code here
            self.thread = threading.Thread(target=self._control_thread)
            self.thread.start()

    def stop(self):
        """
        Stops the processing thread. This call blocks until the processing thread exits.
        """
        if self._stop_thread == False:
            # Send a dummy message to wakeup the thread
            self.sendCommand(self.stop_cmd)
            self._stop_thread = True
            self.wait_for_exit()

    def __del__(self):
        self.stop()

